#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define maxVertices 1000
#define maxEdges 1000000
int graph[maxVertices][maxVertices];
/* Input graph must be undirected,weighted and connected*/
typedef struct Edge
{
        int from,to,weight;
}Edge;
int compare(const void * x,const void * y)
{
        return (*(Edge *)x).weight - (*(Edge *)y).weight;
}
Edge E[maxEdges];
int parent[maxVertices];
void init(int vertices)
{
        int iter=0;
        for(iter=0;iter<vertices;iter++)
        {
                parent[iter]=-1;
        }

}
int findSet(int vertex)
{
        if(parent[vertex]==-1)return vertex;
        return parent[vertex] = findSet(parent[vertex]); /* Finding its parent as well as updating the parent
                                                         of all vertices along this path */
}
int unionSet(int parent1,int parent2)
{
        /* This can be implemented in many other ways. This is one of them */
        parent[parent1] = parent2;
}
void Kruskal(int vertices,int edges)
{
        memset(graph,-1,sizeof(graph)); /* -1 represents the absence of edge between them */
        /* Sort the edges according to the weight */
        qsort(E,edges,sizeof(Edge),compare);
        /* Initialize parents of all vertices to be -1.*/
        init(vertices);
        int totalEdges = 0,edgePos=0,from,to,weight;
        Edge now;
        while(totalEdges < vertices -1)
        {
                if(edgePos==edges)
                {
                        /* Input Graph is not connected*/
                        exit(0);
                }
                now = E[edgePos++];
                from = now.from;
                to = now.to;
                weight=now.weight;
                /* See If vetices from,to are connected. If they are connected do not add this edge. */
                int parent1 = findSet(from);
                int parent2 = findSet(to);
                if(parent1!=parent2)
                {
                        graph[from][to] = weight;
                        unionSet(parent1,parent2);
                        totalEdges++;
                }
        }

}
int main()
{
	int** a;
	a = (int**)malloc(sizeof(int)*3);
	for (int i = 0; i < 3; i++) {
		*a=(int*)malloc(sizeof(int)*2);
	}
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 2; j++) {
			a[i][j]=i*j;
		}
	}
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 2; j++) {
			printf("%d", a[i][j]);
		}
	}
//        int vertices,edges;
//        scanf("%d%d",&vertices,&edges);
//        int iter,jter;
//        int from,to,weight;
//        for(iter=0;iter<edges;iter++)
//        {
//                scanf("%d%d%d",&from,&to,&weight);
//                E[iter].from = from;
//                E[iter].to = to;
//                E[iter].weight = weight;
//        }
//        /* Finding MST */
//        Kruskal(vertices,edges);
//        /* Printing the MST */
//        for(iter=0;iter<vertices;iter++)
//        {
//                for(jter=0;jter<vertices;jter++)
//                {
//                        if(graph[iter][jter]!=-1)
//                        {
//                                printf("Vertex %d and %d, weight %d\n",iter,jter,graph[iter][jter]);
//                        }
//                }
//        }
        return 0;
}
